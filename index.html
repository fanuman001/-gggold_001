<script>
// ... (API, KEY, HEAD 等初始化代碼保持不變) ...

// --- 修正 1：遊戲匯入必須雙重寫入 ---
async function confirmImport() {
    const idx = document.getElementById('h-select').value;
    if(idx === "") return;

    for(let item of parsedGame) {
        const p = players.find(x => x.name.includes(item.name) || item.name.includes(x.name.replace('OFF_','')));
        if(p) {
            // A. 更新玩家債務 (players 表)
            await fetch(`${API}/players?id=eq.${p.id}`, { 
                method: 'PATCH', 
                headers: HEAD, 
                body: JSON.stringify({ debt: (p.debt || 0) + item.amount }) 
            });
            
            // B. 強制寫入歷史明細 (ledger_logs 表) - 這是發票數字的來源
            const logPayload = {
                type: 'game',
                note: '遊戲結單匯入',
                payer_name: p.name,
                total_amount: item.amount,
                per_share: item.amount,
                detail_json: { 
                    payer_id: p.id.toString(), 
                    participants: [p.id.toString()] 
                }
            };
            
            const logRes = await fetch(`${API}/ledger_logs`, { 
                method: 'POST', 
                headers: HEAD, 
                body: JSON.stringify(logPayload) 
            });
            
            if(!logRes.ok) console.error("日誌寫入失敗:", await logRes.text());
        }
    }
    
    // 標記該單據已匯入
    await fetch(`${API}/history?id=eq.${hInbox[idx].id}`, { 
        method: 'PATCH', 
        headers: HEAD, 
        body: JSON.stringify({ description: hInbox[idx].description + " [已匯入]" })
    });
    
    alert("遊戲帳目已寫入玩家債務與發票日誌");
    init();
}

// --- 修正 2：生活雜支必須雙重寫入 ---
async function confirmExp() {
    const pId = document.getElementById('payer-id').value;
    const amt = parseFloat(document.getElementById('exp-amt').value);
    const note = document.getElementById('exp-note').value || "生活雜支";
    const sharers = Array.from(document.querySelectorAll('.p-btn.active')).map(el => el.dataset.id);
    
    if(!amt || sharers.length === 0) return alert("請輸入金額並選擇分攤成員");
    
    const per = amt / sharers.length;
    const payerObj = players.find(x => x.id == pId);

    // A. 循環更新所有受影響玩家的餘額 (players 表)
    for(let p of players) {
        let diff = (p.id == pId ? amt : 0) - (sharers.includes(p.id.toString()) ? per : 0);
        if(Math.abs(diff) > 0.01) {
            await fetch(`${API}/players?id=eq.${p.id}`, { 
                method: 'PATCH', 
                headers: HEAD, 
                body: JSON.stringify({ debt: (p.debt || 0) + diff }) 
            });
        }
    }

    // B. 同步寫入一筆雜支總紀錄 (ledger_logs 表) - 讓發票抓得到這筆分帳
    const logPayload = {
        type: 'exp',
        note: note,
        payer_name: payerObj.name,
        total_amount: amt,
        per_share: per,
        detail_json: { 
            payer_id: pId.toString(), 
            participants: sharers 
        }
    };

    const logRes = await fetch(`${API}/ledger_logs`, { 
        method: 'POST', 
        headers: HEAD, 
        body: JSON.stringify(logPayload) 
    });

    if(logRes.ok) {
        alert("生活開支已成功寫入資料庫與發票");
        document.getElementById('exp-amt').value = "";
        init();
    } else {
        alert("寫入失敗，請檢查資料表權限");
    }
}
</script>
